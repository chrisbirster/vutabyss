// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: decks.query.sql

package database

import (
	"context"
	"database/sql"
)

const addDeckCollaborator = `-- name: AddDeckCollaborator :one
INSERT INTO deck_collaborator (
  deck_id,
  user_id,
  role
)
VALUES (?, ?, ?)
RETURNING id, deck_id, user_id, role, created_at, updated_at
`

type AddDeckCollaboratorParams struct {
	DeckID string `json:"deck_id"`
	UserID string `json:"user_id"`
	Role   string `json:"role"`
}

func (q *Queries) AddDeckCollaborator(ctx context.Context, arg AddDeckCollaboratorParams) (DeckCollaborator, error) {
	row := q.db.QueryRowContext(ctx, addDeckCollaborator, arg.DeckID, arg.UserID, arg.Role)
	var i DeckCollaborator
	err := row.Scan(
		&i.ID,
		&i.DeckID,
		&i.UserID,
		&i.Role,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createDeck = `-- name: CreateDeck :one
INSERT INTO deck (
  name,
  owner_id,
  description
)
VALUES (?, ?, ?)
RETURNING id, name, owner_id, description, created_at, updated_at, card_count
`

type CreateDeckParams struct {
	Name        string         `json:"name"`
	OwnerID     string         `json:"owner_id"`
	Description sql.NullString `json:"description"`
}

func (q *Queries) CreateDeck(ctx context.Context, arg CreateDeckParams) (Deck, error) {
	row := q.db.QueryRowContext(ctx, createDeck, arg.Name, arg.OwnerID, arg.Description)
	var i Deck
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.OwnerID,
		&i.Description,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CardCount,
	)
	return i, err
}

const deleteDeck = `-- name: DeleteDeck :exec
DELETE FROM deck
WHERE id = ?
`

func (q *Queries) DeleteDeck(ctx context.Context, id string) error {
	_, err := q.db.ExecContext(ctx, deleteDeck, id)
	return err
}

const getDeck = `-- name: GetDeck :one
SELECT id, name, owner_id, description, created_at, updated_at, card_count FROM deck
WHERE id = ?
LIMIT 1
`

func (q *Queries) GetDeck(ctx context.Context, id string) (Deck, error) {
	row := q.db.QueryRowContext(ctx, getDeck, id)
	var i Deck
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.OwnerID,
		&i.Description,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CardCount,
	)
	return i, err
}

const getDeckById = `-- name: GetDeckById :one
SELECT id, name, owner_id, description, created_at, updated_at, card_count FROM deck
WHERE id = ?
LIMIT 1
`

func (q *Queries) GetDeckById(ctx context.Context, id string) (Deck, error) {
	row := q.db.QueryRowContext(ctx, getDeckById, id)
	var i Deck
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.OwnerID,
		&i.Description,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CardCount,
	)
	return i, err
}

const listDeckCollaborators = `-- name: ListDeckCollaborators :many
SELECT id, deck_id, user_id, role, created_at, updated_at FROM deck_collaborator
WHERE deck_id = ?
`

func (q *Queries) ListDeckCollaborators(ctx context.Context, deckID string) ([]DeckCollaborator, error) {
	rows, err := q.db.QueryContext(ctx, listDeckCollaborators, deckID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []DeckCollaborator
	for rows.Next() {
		var i DeckCollaborator
		if err := rows.Scan(
			&i.ID,
			&i.DeckID,
			&i.UserID,
			&i.Role,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listDecksByOwnerId = `-- name: ListDecksByOwnerId :many
SELECT id, name, owner_id, description, created_at, updated_at, card_count FROM deck
WHERE owner_id = ?
ORDER BY id
`

func (q *Queries) ListDecksByOwnerId(ctx context.Context, ownerID string) ([]Deck, error) {
	rows, err := q.db.QueryContext(ctx, listDecksByOwnerId, ownerID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Deck
	for rows.Next() {
		var i Deck
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.OwnerID,
			&i.Description,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CardCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSharedDecks = `-- name: ListSharedDecks :many
SELECT deck.id, deck.name, deck.owner_id, deck.description, deck.created_at, deck.updated_at, deck.card_count
FROM deck
JOIN deck_collaborator ON deck.id = deck_collaborator.deck_id
WHERE deck_collaborator.user_id = ?
ORDER BY deck.id
`

func (q *Queries) ListSharedDecks(ctx context.Context, userID string) ([]Deck, error) {
	rows, err := q.db.QueryContext(ctx, listSharedDecks, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Deck
	for rows.Next() {
		var i Deck
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.OwnerID,
			&i.Description,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CardCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const removeDeckCollaborator = `-- name: RemoveDeckCollaborator :exec
DELETE FROM deck_collaborator
WHERE id = ?
`

func (q *Queries) RemoveDeckCollaborator(ctx context.Context, id string) error {
	_, err := q.db.ExecContext(ctx, removeDeckCollaborator, id)
	return err
}

const updateDeck = `-- name: UpdateDeck :one
UPDATE deck
SET
  name = ?,
  description = ?,
  updated_at = CURRENT_TIMESTAMP
WHERE id = ?
RETURNING id, name, owner_id, description, created_at, updated_at, card_count
`

type UpdateDeckParams struct {
	Name        string         `json:"name"`
	Description sql.NullString `json:"description"`
	ID          string         `json:"id"`
}

func (q *Queries) UpdateDeck(ctx context.Context, arg UpdateDeckParams) (Deck, error) {
	row := q.db.QueryRowContext(ctx, updateDeck, arg.Name, arg.Description, arg.ID)
	var i Deck
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.OwnerID,
		&i.Description,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CardCount,
	)
	return i, err
}

const updateDeckCollaborator = `-- name: UpdateDeckCollaborator :one
UPDATE deck_collaborator
SET role = ?,
    updated_at = CURRENT_TIMESTAMP
WHERE deck_id = ?
  AND user_id = ?
RETURNING id, deck_id, user_id, role, created_at, updated_at
`

type UpdateDeckCollaboratorParams struct {
	Role   string `json:"role"`
	DeckID string `json:"deck_id"`
	UserID string `json:"user_id"`
}

func (q *Queries) UpdateDeckCollaborator(ctx context.Context, arg UpdateDeckCollaboratorParams) (DeckCollaborator, error) {
	row := q.db.QueryRowContext(ctx, updateDeckCollaborator, arg.Role, arg.DeckID, arg.UserID)
	var i DeckCollaborator
	err := row.Scan(
		&i.ID,
		&i.DeckID,
		&i.UserID,
		&i.Role,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
