// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: cards.query.sql

package database

import (
	"context"
	"database/sql"
	"time"
)

const cardDetailsByDeck = `-- name: CardDetailsByDeck :many
SELECT
    n.id AS note_id,
    nt.name       as note_name,
    nt.description as note_description,
    nt.id AS note_type_id,
    nt.name AS note_type_name,
    nf.id AS note_field_id,
    nf.field_name,
    nf.field_content,
    d.id AS deck_id,
    d.name AS deck_name,
    d.description AS deck_description,
    d.owner_id,
    c.due_date,
    c.id AS card_id,
    c.stability,
    c.difficulty,
    c.interval,
    c.status,
    c.reps,
    c.lapses,
    c.created_at,
    c.updated_at,
    ct.template_name,
    ct.front_html,
    ct.back_html,
    ct.css
FROM
    note n
JOIN
    note_type nt ON n.note_type_id = nt.id
JOIN
    deck d ON n.deck_id = d.id
JOIN
    card c ON n.id = c.note_id
JOIN
    card_template ct ON c.card_template_id = ct.id
LEFT JOIN
    note_field nf ON n.id = nf.note_id
WHERE
    d.id = ?
ORDER BY c.created_at
`

type CardDetailsByDeckRow struct {
	NoteID          string          `json:"note_id"`
	NoteName        string          `json:"note_name"`
	NoteDescription sql.NullString  `json:"note_description"`
	NoteTypeID      string          `json:"note_type_id"`
	NoteTypeName    string          `json:"note_type_name"`
	NoteFieldID     sql.NullString  `json:"note_field_id"`
	FieldName       sql.NullString  `json:"field_name"`
	FieldContent    sql.NullString  `json:"field_content"`
	DeckID          string          `json:"deck_id"`
	DeckName        string          `json:"deck_name"`
	DeckDescription sql.NullString  `json:"deck_description"`
	OwnerID         string          `json:"owner_id"`
	DueDate         sql.NullTime    `json:"due_date"`
	CardID          string          `json:"card_id"`
	Stability       sql.NullFloat64 `json:"stability"`
	Difficulty      sql.NullFloat64 `json:"difficulty"`
	Interval        sql.NullInt64   `json:"interval"`
	Status          sql.NullString  `json:"status"`
	Reps            sql.NullInt64   `json:"reps"`
	Lapses          sql.NullInt64   `json:"lapses"`
	CreatedAt       time.Time       `json:"created_at"`
	UpdatedAt       time.Time       `json:"updated_at"`
	TemplateName    string          `json:"template_name"`
	FrontHtml       string          `json:"front_html"`
	BackHtml        string          `json:"back_html"`
	Css             sql.NullString  `json:"css"`
}

func (q *Queries) CardDetailsByDeck(ctx context.Context, id string) ([]CardDetailsByDeckRow, error) {
	rows, err := q.db.QueryContext(ctx, cardDetailsByDeck, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []CardDetailsByDeckRow
	for rows.Next() {
		var i CardDetailsByDeckRow
		if err := rows.Scan(
			&i.NoteID,
			&i.NoteName,
			&i.NoteDescription,
			&i.NoteTypeID,
			&i.NoteTypeName,
			&i.NoteFieldID,
			&i.FieldName,
			&i.FieldContent,
			&i.DeckID,
			&i.DeckName,
			&i.DeckDescription,
			&i.OwnerID,
			&i.DueDate,
			&i.CardID,
			&i.Stability,
			&i.Difficulty,
			&i.Interval,
			&i.Status,
			&i.Reps,
			&i.Lapses,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.TemplateName,
			&i.FrontHtml,
			&i.BackHtml,
			&i.Css,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const createCard = `-- name: CreateCard :one
INSERT INTO card (
  note_id,
  card_template_id,
  due_date,
  stability,
  difficulty,
  interval,
  status
)
VALUES (?, ?, ?, ?, ?, ?, ?)
RETURNING id, note_id, card_template_id, due_date, stability, difficulty, interval, status, reps, lapses, created_at, updated_at
`

type CreateCardParams struct {
	NoteID         string          `json:"note_id"`
	CardTemplateID string          `json:"card_template_id"`
	DueDate        sql.NullTime    `json:"due_date"`
	Stability      sql.NullFloat64 `json:"stability"`
	Difficulty     sql.NullFloat64 `json:"difficulty"`
	Interval       sql.NullInt64   `json:"interval"`
	Status         sql.NullString  `json:"status"`
}

func (q *Queries) CreateCard(ctx context.Context, arg CreateCardParams) (Card, error) {
	row := q.db.QueryRowContext(ctx, createCard,
		arg.NoteID,
		arg.CardTemplateID,
		arg.DueDate,
		arg.Stability,
		arg.Difficulty,
		arg.Interval,
		arg.Status,
	)
	var i Card
	err := row.Scan(
		&i.ID,
		&i.NoteID,
		&i.CardTemplateID,
		&i.DueDate,
		&i.Stability,
		&i.Difficulty,
		&i.Interval,
		&i.Status,
		&i.Reps,
		&i.Lapses,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteCard = `-- name: DeleteCard :exec
DELETE FROM card
WHERE id = ?
`

func (q *Queries) DeleteCard(ctx context.Context, id string) error {
	_, err := q.db.ExecContext(ctx, deleteCard, id)
	return err
}

const getCard = `-- name: GetCard :one
SELECT id, note_id, card_template_id, due_date, stability, difficulty, interval, status, reps, lapses, created_at, updated_at FROM card
WHERE id = ?
LIMIT 1
`

func (q *Queries) GetCard(ctx context.Context, id string) (Card, error) {
	row := q.db.QueryRowContext(ctx, getCard, id)
	var i Card
	err := row.Scan(
		&i.ID,
		&i.NoteID,
		&i.CardTemplateID,
		&i.DueDate,
		&i.Stability,
		&i.Difficulty,
		&i.Interval,
		&i.Status,
		&i.Reps,
		&i.Lapses,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listCardsByDeck = `-- name: ListCardsByDeck :many
SELECT c.id,
       c.note_id,
       c.card_template_id,
       c.due_date,
       c.stability,
       c.difficulty,
       c.interval,
       c.status,
       c.reps,
       c.lapses,
       c.created_at,
       c.updated_at
FROM card AS c
JOIN note AS n ON c.note_id = n.id
WHERE n.deck_id = ?
`

func (q *Queries) ListCardsByDeck(ctx context.Context, deckID string) ([]Card, error) {
	rows, err := q.db.QueryContext(ctx, listCardsByDeck, deckID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Card
	for rows.Next() {
		var i Card
		if err := rows.Scan(
			&i.ID,
			&i.NoteID,
			&i.CardTemplateID,
			&i.DueDate,
			&i.Stability,
			&i.Difficulty,
			&i.Interval,
			&i.Status,
			&i.Reps,
			&i.Lapses,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listCardsByNote = `-- name: ListCardsByNote :many
SELECT id, note_id, card_template_id, due_date, stability, difficulty, interval, status, reps, lapses, created_at, updated_at FROM card
WHERE note_id = ?
ORDER BY id
`

func (q *Queries) ListCardsByNote(ctx context.Context, noteID string) ([]Card, error) {
	rows, err := q.db.QueryContext(ctx, listCardsByNote, noteID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Card
	for rows.Next() {
		var i Card
		if err := rows.Scan(
			&i.ID,
			&i.NoteID,
			&i.CardTemplateID,
			&i.DueDate,
			&i.Stability,
			&i.Difficulty,
			&i.Interval,
			&i.Status,
			&i.Reps,
			&i.Lapses,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateCardScheduling = `-- name: UpdateCardScheduling :one
UPDATE card
SET
  due_date = ?,
  stability = ?,
  difficulty = ?,
  interval = ?,
  status = ?,
  reps = ?,
  lapses = ?,
  updated_at = CURRENT_TIMESTAMP
WHERE id = ?
RETURNING id, note_id, card_template_id, due_date, stability, difficulty, interval, status, reps, lapses, created_at, updated_at
`

type UpdateCardSchedulingParams struct {
	DueDate    sql.NullTime    `json:"due_date"`
	Stability  sql.NullFloat64 `json:"stability"`
	Difficulty sql.NullFloat64 `json:"difficulty"`
	Interval   sql.NullInt64   `json:"interval"`
	Status     sql.NullString  `json:"status"`
	Reps       sql.NullInt64   `json:"reps"`
	Lapses     sql.NullInt64   `json:"lapses"`
	ID         string          `json:"id"`
}

func (q *Queries) UpdateCardScheduling(ctx context.Context, arg UpdateCardSchedulingParams) (Card, error) {
	row := q.db.QueryRowContext(ctx, updateCardScheduling,
		arg.DueDate,
		arg.Stability,
		arg.Difficulty,
		arg.Interval,
		arg.Status,
		arg.Reps,
		arg.Lapses,
		arg.ID,
	)
	var i Card
	err := row.Scan(
		&i.ID,
		&i.NoteID,
		&i.CardTemplateID,
		&i.DueDate,
		&i.Stability,
		&i.Difficulty,
		&i.Interval,
		&i.Status,
		&i.Reps,
		&i.Lapses,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
