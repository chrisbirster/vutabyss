// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: cards.query.sql

package database

import (
	"context"
	"database/sql"
)

const cardDetailsByDeck = `-- name: CardDetailsByDeck :many
SELECT
    n.id AS note_id,
    nt.id AS note_type_id,
    nt.name AS note_type_name,
    nf.id AS note_field_id,
    nf.field_name,
    nf.field_content,
    d.id AS deck_id,
    d.name AS deck_name,
    d.description AS deck_description,
    c.due_date,
    c.id AS card_id,
    ct.template_name,
    ct.front_html,
    ct.back_html
FROM
    note n
JOIN
    note_type nt ON n.note_type_id = nt.id
JOIN
    deck d ON n.deck_id = d.id
JOIN
    card c ON n.id = c.note_id
JOIN
    card_template ct ON c.card_template_id = ct.id
LEFT JOIN
    note_field nf ON n.id = nf.note_id
WHERE
    d.id = ?
ORDER BY c.created_at
`

type CardDetailsByDeckRow struct {
	NoteID          string         `json:"note_id"`
	NoteTypeID      string         `json:"note_type_id"`
	NoteTypeName    string         `json:"note_type_name"`
	NoteFieldID     sql.NullString `json:"note_field_id"`
	FieldName       sql.NullString `json:"field_name"`
	FieldContent    sql.NullString `json:"field_content"`
	DeckID          string         `json:"deck_id"`
	DeckName        string         `json:"deck_name"`
	DeckDescription sql.NullString `json:"deck_description"`
	DueDate         sql.NullTime   `json:"due_date"`
	CardID          string         `json:"card_id"`
	TemplateName    string         `json:"template_name"`
	FrontHtml       string         `json:"front_html"`
	BackHtml        string         `json:"back_html"`
}

func (q *Queries) CardDetailsByDeck(ctx context.Context, id string) ([]CardDetailsByDeckRow, error) {
	rows, err := q.db.QueryContext(ctx, cardDetailsByDeck, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []CardDetailsByDeckRow
	for rows.Next() {
		var i CardDetailsByDeckRow
		if err := rows.Scan(
			&i.NoteID,
			&i.NoteTypeID,
			&i.NoteTypeName,
			&i.NoteFieldID,
			&i.FieldName,
			&i.FieldContent,
			&i.DeckID,
			&i.DeckName,
			&i.DeckDescription,
			&i.DueDate,
			&i.CardID,
			&i.TemplateName,
			&i.FrontHtml,
			&i.BackHtml,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const createCard = `-- name: CreateCard :one
INSERT INTO card (
  note_id,
  card_template_id,
  due_date,
  stability,
  difficulty,
  interval,
  status
)
VALUES (?, ?, ?, ?, ?, ?, ?)
RETURNING id, note_id, card_template_id, due_date, stability, difficulty, interval, status, reps, lapses, created_at, updated_at
`

type CreateCardParams struct {
	NoteID         string          `json:"note_id"`
	CardTemplateID string          `json:"card_template_id"`
	DueDate        sql.NullTime    `json:"due_date"`
	Stability      sql.NullFloat64 `json:"stability"`
	Difficulty     sql.NullFloat64 `json:"difficulty"`
	Interval       sql.NullInt64   `json:"interval"`
	Status         sql.NullString  `json:"status"`
}

func (q *Queries) CreateCard(ctx context.Context, arg CreateCardParams) (Card, error) {
	row := q.db.QueryRowContext(ctx, createCard,
		arg.NoteID,
		arg.CardTemplateID,
		arg.DueDate,
		arg.Stability,
		arg.Difficulty,
		arg.Interval,
		arg.Status,
	)
	var i Card
	err := row.Scan(
		&i.ID,
		&i.NoteID,
		&i.CardTemplateID,
		&i.DueDate,
		&i.Stability,
		&i.Difficulty,
		&i.Interval,
		&i.Status,
		&i.Reps,
		&i.Lapses,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteCard = `-- name: DeleteCard :exec
DELETE FROM card
WHERE id = ?
`

func (q *Queries) DeleteCard(ctx context.Context, id string) error {
	_, err := q.db.ExecContext(ctx, deleteCard, id)
	return err
}

const getCard = `-- name: GetCard :one
SELECT id, note_id, card_template_id, due_date, stability, difficulty, interval, status, reps, lapses, created_at, updated_at FROM card
WHERE id = ?
LIMIT 1
`

func (q *Queries) GetCard(ctx context.Context, id string) (Card, error) {
	row := q.db.QueryRowContext(ctx, getCard, id)
	var i Card
	err := row.Scan(
		&i.ID,
		&i.NoteID,
		&i.CardTemplateID,
		&i.DueDate,
		&i.Stability,
		&i.Difficulty,
		&i.Interval,
		&i.Status,
		&i.Reps,
		&i.Lapses,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listCardsByNote = `-- name: ListCardsByNote :many
SELECT id, note_id, card_template_id, due_date, stability, difficulty, interval, status, reps, lapses, created_at, updated_at FROM card
WHERE note_id = ?
ORDER BY id
`

func (q *Queries) ListCardsByNote(ctx context.Context, noteID string) ([]Card, error) {
	rows, err := q.db.QueryContext(ctx, listCardsByNote, noteID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Card
	for rows.Next() {
		var i Card
		if err := rows.Scan(
			&i.ID,
			&i.NoteID,
			&i.CardTemplateID,
			&i.DueDate,
			&i.Stability,
			&i.Difficulty,
			&i.Interval,
			&i.Status,
			&i.Reps,
			&i.Lapses,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateCardScheduling = `-- name: UpdateCardScheduling :one
UPDATE card
SET
  due_date = ?,
  stability = ?,
  difficulty = ?,
  interval = ?,
  status = ?,
  reps = ?,
  lapses = ?,
  updated_at = CURRENT_TIMESTAMP
WHERE id = ?
RETURNING id, note_id, card_template_id, due_date, stability, difficulty, interval, status, reps, lapses, created_at, updated_at
`

type UpdateCardSchedulingParams struct {
	DueDate    sql.NullTime    `json:"due_date"`
	Stability  sql.NullFloat64 `json:"stability"`
	Difficulty sql.NullFloat64 `json:"difficulty"`
	Interval   sql.NullInt64   `json:"interval"`
	Status     sql.NullString  `json:"status"`
	Reps       sql.NullInt64   `json:"reps"`
	Lapses     sql.NullInt64   `json:"lapses"`
	ID         string          `json:"id"`
}

func (q *Queries) UpdateCardScheduling(ctx context.Context, arg UpdateCardSchedulingParams) (Card, error) {
	row := q.db.QueryRowContext(ctx, updateCardScheduling,
		arg.DueDate,
		arg.Stability,
		arg.Difficulty,
		arg.Interval,
		arg.Status,
		arg.Reps,
		arg.Lapses,
		arg.ID,
	)
	var i Card
	err := row.Scan(
		&i.ID,
		&i.NoteID,
		&i.CardTemplateID,
		&i.DueDate,
		&i.Stability,
		&i.Difficulty,
		&i.Interval,
		&i.Status,
		&i.Reps,
		&i.Lapses,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
